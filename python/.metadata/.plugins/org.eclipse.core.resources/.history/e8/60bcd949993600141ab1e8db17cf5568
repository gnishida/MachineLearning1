import math
import copy

# Example
class Example:
	def __init__(self, row, label, weight):
		self.row = row
		self.label = label
		self.weight = weight

# Decision Tree Node class
class TreeNode:
	def __init__(self, attr_index, attr_type, attr_th, isLeaf, label):
		self.attr_index = attr_index
		self.attr_type = attr_type
		self.attr_th = attr_th
		self.childNodes = {}
		self.isLeaf = isLeaf
		self.label = label

	def addChildNode(self, value, childNode):
		self.childNodes[value] = childNode

	def display(self, indent):
		if self.isLeaf:
			print(" " * indent + "Leaf: " + self.label)
			return

		print(" " * indent + "Attribute: " + str(self.attr_index))
		if self.attr_type == "C":
			print(" " * indent + "threshold: " + str(self.attr_th))
		for value, childNode in self.childNodes.iteritems():
			print(" " * (indent + 4) + "[value: " + str(value) + "]")
			childNode.display(indent + 4)

	def predict(self, row):
		if self.isLeaf == True:
			return self.label
		elif self.attr_type == "B":
			return self.childNodes[row[self.attr_index]].predict(row)
		else:
			if float(row[self.attr_index]) < self.attr_th:
				return self.childNodes["<"].predict(row)
			else:
				return self.childNodes[">"].predict(row)

def DecisionTree():
	#TODO: Your code starts from here.
	#      This function should return a list of labels.
	#      e.g.:
	#	labels = [['+','-','+'],['+','+','-'],['-','+'],['+','+']]
	#	return labels
	#	where:
	#		labels[0] = original_training_labels
	#		labels[1] = prediected_training_labels
	#		labels[2] = original_testing_labels
	#		labels[3] = predicted_testing_labels




	return


def DecisionTree(maxDepth):
	#TODO: Your code starts from here.
	#      This function should return a list of labels.
	#      e.g.:
	#	labels = [['+','-','+'],['+','+','-'],['-','+'],['+','+']]
	#	return labels
	#	where:
	#		labels[0] = original_training_labels
	#		labels[1] = prediected_training_labels
	#		labels[2] = original_testing_labels
	#		labels[3] = predicted_testing_labels


	# define the attributes
	attrs = {0: "B", 1: "C", 2: "C", 3: "B", 4: "B", 5: "B", 6: "B", 7: "C", 8: "B", 9: "B", 10: "C", 11: "B", 12: "B", 13: "C", 14: "C"}

	# read test data
	exammples = readTestData("train.txt")

	rootNode = createSubTree(exammples, attrs, maxDepth)
	rootNode.display(0)

	labels = []
	numCorrect = 0
	for i in xrange(len(rows)):
		label = rootNode.predict(rows[i])
		if rows[i][15] == label:
			numCorrect += 1
		labels.append(label)

	print(labels)
	print("Accuracy: " + str(float(numCorrect) / float(len(rows))))

	return

# create subtree of the decision tree
def createSubTree(exammples, attrs, maxDepth):
	# if all the examples are labeled the same, return a leaf node with label
	if isAllExampleSame(exammples):
		return TreeNode(-1, "", 0, True, exammples[0].label)

	attr_index, attr_th = findBestAttribute(exammples, attrs)
	if attr_index == -1:
		print("Unexpected error!!!!")
		return TreeNode(-1, "", 0, True, "?")

	node = TreeNode(attr_index, attrs[attr_index], attr_th, False, "")

	splitted_examples = split(exammples, attr_index, attrs[attr_index], attr_th)
	for value, subset in splitted_examples.iteritems():
		if len(subset) == 0:
			print("no data in this subset. unexpected error!!!!")
			continue
		#elif maxDepth == 0: continue
		else:
			child = createSubTree(subset, attrs, maxDepth - 1)
			node.addChildNode(value, child)

	return node

# check if all the examples are labeled the same
def isAllExampleSame(examples):
	if len(examples) == 0: return True

	label = examples[0].label
	for i in xrange(len(examples)):
		if examples[i].label != label: return False
	return True

# find the best attribute to get the highest information gain
def findBestAttribute(examples, attrs):
	e = entropy(examples)

	max_gain = 0
	attr_index = -1
	attr_th = 0

	for index, type in attrs.iteritems():
		if type == "B":
			splitted_rows = split(examples, index, type, 0)
			e2 = totalEntropy(splitted_rows)
			gain = e - e2
			if gain > max_gain:
				max_gain = gain
				attr_index = index
		else:
			thresholds = findThresholds(rows, index)
			for i in xrange(len(thresholds)):
				splitted_rows = split(rows, index, type, thresholds[i])
				e2 = totalEntropy(splitted_rows)
				gain = e - e2
				if gain > max_gain:
					max_gain = gain
					attr_index = index
					attr_th = thresholds[i]

	return attr_index, attr_th

# find the thresholds
def findThresholds(examples, attr_index):
	thresholds = []

	# extract only valid values
	examples2 = []
	for example in examples:
		if example[attr_index] == "?": continue
		examples2.append(example)

	if len(examples2) == 0: return thresholds

	# sort
	#rows2 = sorted(rows, key=lambda row: float(row[attr_index]))
	examples2.sort(key=lambda example: float(example.row[attr_index]))

	previous_label = examples2[0].label
	previous_value = float(examples2[0].row[attr_index])
	for example2 in examples2:
		if example2.label != previous_label:
			previous_label = example2.label
			thresholds.append((previous_value + float(example2.row[attr_index])) * 0.5)
		previous_value = float(example2.row[attr_index])

	return thresholds

# split data by a given attribute
def split(examples, attr_index, attr_type, attr_th):
	splitted_examples = {}
	if attr_type == "B":
		for example in examples:
			value = example.row[attr_index]
			if not value in splitted_examples:
				splitted_examples[value] = []
			splitted_examples[value].append(example)
	else:
		splitted_examples["<"] = []
		splitted_examples[">"] = []
		for example in examples:
			value = float(example.row[attr_index])
			if value < attr_th:
				splitted_examples["<"].append(example)
			else:
				splitted_examples[">"].append(example)

	return splitted_examples

# compute Entropy of all the subset
def totalEntropy(splitted_examples):
	total = 0
	total_num = 0

	for value, examples in splitted_examples.iteritems():
		num = len(examples)
		e = entropy(examples)
		total += e * num
		total_num += num

	return total / total_num

# compute Entropy for a given data set
def entropy(examples):
	if len(examples) == 0: return 0

	num_positive = 0
	num_negative = 0
	for example in examples:
		if example.label == '+':
			num_positive += 1
		else:
			num_negative += 1

	if num_positive == 0 or num_negative == 0: return 0

	p = float(num_positive) / float(num_positive + num_negative)
	n = float(num_negative) / float(num_positive + num_negative)

	return -p * math.log(p, 2) - n * math.log(n, 2)

#readfile:
#   Input: filename
#   Output: return a list of rows.
def readTestData(filename):
	f = open(filename).read()
	examples = []
	for line in f.split('\r'): # for mac, we use \r
		row = line.split('\t')
		label = row[len(row) - 1]
		row.pop(len(row) - 1)
		examples.append(Example(row, label, 1.0))

	return examples


if __name__ == '__main__':
	DecisionTree(10)
